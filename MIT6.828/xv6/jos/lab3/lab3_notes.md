# Lab3 :User Environments  
## Introduction  
在这一实验中你将完成基本的内核设施使得可以在受保护的用户模式环境下运行。你将增强JOS来设置数据结构来跟踪用户环境，创造一个单用户的环境，加载一个程序映像，并使他开始运行。你也将使得JOS内核可以处理任何的系统调用以及其他异常。  
**注意**:在这一实验中，单词环境和进程是可以交换的，都指代可以让你运行一个进程的抽象。我们使用环境而不是进程来强调JOS环境和UNIX进程提供不同的接口，不提供相同的机制。  
## PART A:用户环境和异常处理  
新包括的文件`inc/env.h`包含了基本的JOS中的用户环境的定义。阅读它。内核使用`ebv`数据结构来跟踪每个用户环境。在这一实验中你将初始的创建一个环境，但是你需要设计JOS内核来支持多环境。lab4将完成这一特征--通过fork调用。  
正如你在`kern/env.c`中看到的，内核维持三个主要的全局变量：  
```
struct Env *envs = NULL;		// All environments
struct Env *curenv = NULL;		// The current env
static struct Env *env_free_list;	// Free environment list
```

一旦JOS开启运行了，`envs`指向`env`结构的数组，代表了系统中所有的环境。在我们的设计中，JOS内核将支持最多`NENV`个同时有效的环境，虽然通常只有少数的环境在给定时间运行(`NENV`是一个常量定义在`inc/env.h`中)。一旦它被分配了，`envs`矩阵对于每个`NENV`可能的环境将包含一个`Env`数据结构的单例。  
JOS内核在`env_free_list`中保持所有的不活跃的`Env`结构。这一设计允许简单的环境的分配与回收，它们只需要从空闲链表中被加或者移除。  
内核使用`curenv`标志来跟踪正在执行的环境。在引导时，在第一个环境运行之前，`curenv`被初始化为NULL。  
### 环境状态  
`Env`结构在`inc/env.h`中被定义为如下：  
```
struct Env {
	struct Trapframe env_tf;	// Saved registers
	struct Env *env_link;		// Next free Env
	envid_t env_id;			// Unique environment identifier
	envid_t env_parent_id;		// env_id of this env's parent
	enum EnvType env_type;		// Indicates special system environments
	unsigned env_status;		// Status of the environment
	uint32_t env_runs;		// Number of times environment has run

	// Address space
	pde_t *env_pgdir;		// Kernel virtual address of page dir
};
```
这些是`Env`的域中是啥：  
**env_tf**:持有当环境不再运行时被保存的寄存器值：也就是，当内核或者不同的环境在运行时。内核保存这些当从用户态到内核态，所以环境接下来可以恢复从中断的地方开始。  
**env_link**:这是到在空闲链表`env_free_lsit`的下一个`Env`的链。`env_free_list`指向链表中的第一个自由的环境。  
**env_id**:内核在这里存储一个值，唯一的表示当前正在运行的环境(也就是，在`envs`矩阵中使用这一特殊的槽)。在一个用户环境终止后，内核可能重新分配相同的`env`结构给不同的环境 - 但是新的环境会有一个不同的`env_id`即使新的环境是重用`envs`矩阵中相同的槽。  
**env_parent_id**:内核在这里保存创建这个环境的`env_id`，用这种方法环境可以形成一个家族树，在决定每个环境可以允许对谁做什么这种安全决策时比较有效。  
**env_type**:被用来区分特殊的环境。对于大多数环境，它将是`ENV_TYPE_USE`。  
**env_status**:五种，自己看把。。  
**env_pgdir**:持有环境的页表目录的内核中的虚拟地址。  
就像一个UNIX进程一样，一个JOS环境将线程和地址空间的概念连在一起。线程被保存的寄存器(`env_tf`域)定义，地址空间被页表目录定义。为了运行一个环境，内核必须用保存的寄存器和合适的地址空间设置CPU。  
我们的`struct Env`和xv6的`proc`比较像。两个结构都有环境的用户模式寄存器状态在`trapframe`中。在JOS中，独立的环境没有它们自己的内核栈而xv6中有。一次只有一个JOS环境在内核中是活跃的，所以JOS只需要一个内核栈。  
### 分配环境矩阵  
在`mem_init`中分配一个矩阵给`Env`结构，叫做`envs`。  
Ex1. 修改`mem_init`，分配和映射`envs`矩阵。这一矩阵由`NENV`个`Env`结构组成。像`pages`矩阵一样，在`envs`的内存也应该被映射成用户只读在`UENVS`。
和pages的分配是一个套路的。。。直接再来一遍就行了。  
### 创造和运行环境  
你现在要写在`kern/env.c`中的代码来运行一个用户进程(下文将把环境变为进程)。因为我们现在还没有文件系统，我们将设置内核在加载一个静态的二进制的嵌入在内核中的映像。  
lab3的`GNUmakefile`生成了一系列的在二进制映像在`obj/usr`目录中。如果你看`kern/Makefrag`，你将注意到一些魔幻的直接链接到内核可执行文件好像它们是`.o`文件。`-b binary`的在链接器中的选项使得这些文件被链接好像原始的二进制文件而不是由编译器生成的`.o`文件。  
练习2：在文件`env.c`中，完成下列函数。  
`env_init`:在`envs`矩阵中初始化所有的`Env`结构体并将它们加到`env_free_list`中。也调用`env_init_percpu`,它配置了分段硬件。  
`env_setup_vm`:分配一个页表目录给新的进程并初始化地址空间中的内核部分  
`region_alloc`:分配以及映射一个进程的物理地址  
`load_icode`:你将需要解析一个ELF二进制文件的映像，很像bootloader已经做的，并且把它的内容加载到新进程的用户地址空间。  
`env_create`:使用`env_alloc`分配一个进程并且调用`load_icode`来加载一个ELF文件映像。  
`env_run`:开始一个给定的进程在用户模式下运行  
在你写这些函数的时候，`cprintf`的`%e`选项是有用的 -- 它打印一个对应错误代码的错误的描述，例如  
```
	r = -E_NO_MEM;
	panic("env_alloc: %e", r);
```

下面是一个调用图：  
``` 
    start (kern/entry.S)
    i386_init (kern/init.c)
        cons_init
        mem_init
        env_init
        trap_init (still incomplete at this point)
        env_create
        env_run
            env_pop_tf

```
如果一切正常，你的系统将会进入用户空间，并且执行`hello`二进制文件，直到它使用`int`指令进行系统调用。在当时JOS还没有设置硬件允许任何形式的从用户空间到内核空间的转换。当CPU发现还没有设置好处理系统调用，它生成一个通用的保护异常，发现不能处理，生成一个double fault异常，发现也不能处理，最后使用被叫作`triple fault`的机制放弃。通常你会看到CPU重置系统重启。虽然这对于合法的应用来说是重要的，对于内核的发展来说并不好，所以在6.828的QEMU中你将看到一个寄存器崩溃以及`Triple fault`信息。  
我们将短暂的address这个问题，但是现在我们可以使用调试器来检查我们已经进入用户模式了。使用`make qemu-gdb`并且在`env_pop_tf`中设置断电，这是在实际进入用户模式前的最后一个函数。使用`si`单步这一函数，处理器将会在`iret`之后进入用户模式。你然后会看到用户进程可执行文件的第一条指令，是`cmpl`指令在`lib/entry.S`中的标志`start`。现在使用`b *0x...`来设置断电在`int $0x30`在`hello`中的`sys_cputs`处。这个`int`是在终端打印一个字符的系统调用。如果你现在不能执行`int`，那么你的地址空间设置有问题，或者程序加载代码有问题。  

练习解答：不想骂自己了都，捣鼓了一天，其实明明是正确的，结果自己不仔细看课程的说明，反而相信博客上的东西，结果在正确的基础上浪费了n多时间，也是醉了。这里要特别注意，估计以前旧版的实验进行到这里时，会不断重启，但是新版的已经改了，上面也说的挺清楚了，因为没有设置中断，此时程序就是会崩，用gdb一步步调试到那里就行，结果这一天都因为没重启白调了。  
`env_init`:这部分是进程链表的初始化，将对应进程结构中的变量初始化就行，需要注意的是空闲进程链表的形成。  
`env_setup_vm`:这部分是给新的进程设置虚拟内存，新分配一页物理页用来当作页表，然后把内核的页表复制给该页表，并且把它赋值给进程页表即可。最后把该页表的物理地址和虚拟地址空间中的`UVPT`位置联系起来。  
`region_alloc`:主要是分配物理页给进程，并且把该物理页的物理地址和传入的虚拟地址对应起来。主要是调用`page_alloc`和`page_insert`  
`load_icode`:主要是把二进制映像加载到进程的地址空间中，主要方法是读取镜像文件的ELF头，然后根据该文件头的信息。调用`region_alloc`分配地址，调用`memmove`复制镜像中的东西。这里有一点没看懂的是中途使用了进程自己的页表，虽然看着很有道理，但是不知道会造成什么影响。。接着把进程中的`tf_eip`设置为程序的入口地址，因为最后是靠`tf_eip`返回的。最后，分配一页物理内存给程序的初始栈。  
`env_create`:相当简单，其实就是调用`env_alloc`和`load_icode`分配一个进程以及加载二进制映像到其中。  
`env_run`:切换进程，将当前进程状态改为`RUNNABLE`，将传入的进程参数改为当前进程，最后的`env_pop_tf`,其实就是切换到该进程运行，因为最后是靠进程的`tf`结构体来保存环境的。之前设置了eip，所以会返回到该处。

### 处理中断和异常  
在这个时刻，第一个在用户空间的`int $0x30`系统调用指令是一个最后期限：一旦处理器进入到用户模式，没有方法出来。你将需要完成基本的异常和系统调用处理，这样对内核来说就可能从用户模式代码恢复处理器的控制。  
### 基本的保护控制传递  
异常和中断都是保护控制转移，导致处理器从用户到内核态并且不给用户模式代码任何机会来接触内核或是其他进程的接口。在英特尔的方式中，一个中断是一个由异步的通常由外界到处理器的事件引起的保护控制转移，例如外部设备I/O活动的通知。一个异常，相反的，是一个由当前正在运行的代码引起的同步的保护控制转移，例如除0或是一个无效的内存引用。  
为了确保这些保护控制转移通常是被保护的，处理器的中断/异常机制被设置成当一个异常或是中断发生时当前正在运行的代码不能随意的选择从哪里以及怎么进入内核。取而代之，处理器确保内核只能在仔细的被控制的情况下进入。在x86中，两个机制一起工作来提供这一保护：  
1. 中断处理描述符表：处理器确保中断和异常只能在一些特殊的，定义良好的由内核自己决定的入口点进入内核。  
x86允许256个不同的中断或是异常入口点，每一个有一个不同的中断向量。一个向量是一个0到255之间的数字。一个中断的向量由中断的来源决定：不同的设备，错误的情况和到内核的应用请求生成不同向量的中断。CPU使用向量作为到处理器的中断描述符表IDT的索引，IDT由内核在内核私人的内存中设置，很像GDT。在这个表中的适当的入口点，处理器加载：  
* 加载到指令指针EIP中的值，指向内核将要处理该异常种类的内核代码  
* 加载到代码段CS中的值，包括异常处理函数将要运行的比特位0-1优先级。（在JOS中异常都在内核模式运行，优先级0）  
2. 任务状态段TSS：处理器需要一个地方来在中断和异常发生之前保存旧的处理器状态，例如原始的`EIP`和`CS`的在处理器进入异常处理函数之前的值，这样异常处理函数后来可以重新加载旧的状态并且继续执行。但是这个存储旧的处理器状态的区域必须被从不具有较高优先级的用户模式代码保护，否则恶意的用户代码可能欺骗内核。  
为了这个原因，x86处理器发生一个中断或是陷阱导致从用户到内核模式的优先级转换时，它也会切换到一个在内核内存中的栈。一个叫做TSS的结构特别指定段选择子以及栈存在的地址。处理器在这个新栈中压入`SS`，`ESP`，`EFLAGS`，`CS`，`EIP`和一个可选的错误代码。然后它从中断描述子中加载`CS`和`EIP`，并且设置`SS`和`ESP`指代新的栈。  
JOS只使用它来定义当发生用户到内核模式下处理器需要切换到的内核栈。因为内核模式是特权级0,处理器使用`ESP0`和`SS0`定义当进入内核模式时的内核栈。  
### 异常和中断的种类  
所有的x86处理器可以生成的同步的异常内在的使用中断向量0到31,因此映射到IDT中0到31条目。例如，一个缺页异常总是通过向量14引起一个异常。大于31的向量只能被软件中断使用，可以由`int`指令产生，又或者是异步的硬件中断。  

### 一个例子  
假设处理器在用户进程中执行代码并且发生了一个除0异常。  
1. 处理器切换到被TSS指定的`SS0`和`ESP0`所定义的栈的区域，在JOS中的值是`GD_KD`和`KSTACKTOP`。  
2. 处理器在内核栈中压入异常的参数，从地址`KSTACKTOP`开始。
```
                     +--------------------+ KSTACKTOP
                     | 0x00000 | old SS   |     " - 4
                     |      old ESP       |     " - 8
                     |     old EFLAGS     |     " - 12
                     | 0x00000 | old CS   |     " - 16
                     |      old EIP       |     " - 20 <---- ESP
                     +--------------------+
```
3. 因为我们在处理一个除0异常，在x86中是向量0,处理器读IDT条目0并且设置`CS:EIP`指向被条目描述的处理函数  
4. 处理函数有了控制权并且处理异常，例如终止用户进程。  
对于x86异常的特别的类型，除了标准的上面的五个东西，处理器还压入一个错误代码。缺页异常，数字14,就是一个重要的例子。当处理器压入错误码时，见下。   
```
                     +--------------------+ KSTACKTOP
                     | 0x00000 | old SS   |     " - 4
                     |      old ESP       |     " - 8
                     |     old EFLAGS     |     " - 12
                     | 0x00000 | old CS   |     " - 16
                     |      old EIP       |     " - 20
                     |     error code     |     " - 24 <---- ESP
                     +--------------------+
```  
### 嵌套的异常和中断  
处理器可以在内核和用户模式发生异常和中断，只有在从用户模式到内核模式时，x86的处理器才会在压入它的旧寄存器状态之自动的切换栈以及通过IDT合适的处理异常。如果处理器已经在内核模式当中断或异常发生时，那么CPU会在相同的内核栈中压入值。通过这种方法，内核可以优雅的处理被内核自己产生的嵌套的中断。这一特性在完成保护时是非常重要的工具，我们将在系统调用章节见到。  
如果处理器已经在内核模式了，并且有一个嵌套的异常，因为它不切换栈，它不保存旧的`SS`或是`ESP`寄存器。  
### 设置IDT  
头文件`inc/trap.h`和`kern/trap.h`包含了关于中断和异常的重要的信息。文件`kern/trap.h`包含严格的属于内核的定义，而`inc/trap.h`包含对于用户级程序和库来说可能比较有用的定义。  
你所要达成的控制流应当是这样的：   
```
      IDT                   trapentry.S         trap.c

+----------------+
|   &handler1    |---------> handler1:          trap (struct Trapframe *tf)
|                |             // do stuff      {
|                |             call trap          // handle the exception/interrupt
|                |             // ...           }
+----------------+
|   &handler2    |--------> handler2:
|                |            // do stuff
|                |            call trap
|                |            // ...
+----------------+
       .
       .
       .
+----------------+
|   &handlerX    |--------> handlerX:
|                |             // do stuff
|                |             call trap
|                |             // ...
+----------------+
```  
每个中断或是异常应当在`trapentry.S`中有自己的处理并且`trap_init`应当用这些处理函数初始化IDT。每个处理函数应当建立起一个`struct trapframe`并且调用`trap`。  
练习4：编辑`trapentry.S`和`trap.c`并完成下面的特性。宏`TRAPHANDLER`和`TRAPHANDLER_NOEC`在`trapentry.S`中应当能帮助你。你将需要在`trapentry.S`中添加一个入口点，对每个定义在`inc/trap.h`中的陷阱，而且你将不得不提供`_alltraps`。你也将修改`trap_init`来初始化`idt`来指向这些入口点。  
你的`_alltraps`应当：
1. 压入值使得栈看起来像是struct Trapframe  
2. 加载`GD_KD`到`ds`和`es`
3. `pushl esp`来传入一个到trapframe的指针  
4. `call trap`
`trapentry.S`:其实就是仿照xv6里面的`trapasm`，只是那里的向量`vector`是用perl脚本写好的，而此处需要我们自己建立向量，建立向量也有安装好的宏，比较简单。最后的`_alltraps`和xv6的几乎是一样的，唯一的不同就是trapframe中少了两个寄存器。  
`trap.c`:补全`trapinit`，其实和`xv6`里面的`tvinit`是一样的，只是这里我只设置了20个左右的向量，而那里设置了256个，有没有必要添加更多的看后续把。  
问题：  
1. 对每个独立的中断和异常的处理函数的目的是什么？(也就是，如果所有的异常/中断都被送到相同的处理函数中，有什么现在完成的特性不能被提供?)  
答：个人觉得m貌似这样就不能区分产生的是什么中断或是异常了。。补充：不同的异常处理需要不同的参数，因此每个中断。异常都需要有各自的处理函数  
2. 你是不是必须做啥事来使得`user/softinit`程序运行正确？成绩脚本希望它产生一个通常的保护异常（陷阱13），但是`softint`的代码表示的是`int $14`。为什么这回产生中断向量13？如果内核实际上允许`softint`的`int $14`指令接触内核的缺页异常会发生什么？  
答：据我猜测，这是因为程序是运行在用户态的，但是`int`指令只能在内核态产生，所以会产生保护错误。如果允许直接产生`int 14`，用户就可以没有内核的许可下分配内存，这样是很危险的。  

## PART B：缺页，断点异常和系统调用  
### 处理缺页异常  
缺页异常，是中断向量14,是一个特别重要的向量。当处理器产生一个缺页错误，它在一个特殊的处理器控制寄存器`CR2`中存储引起错误的线性地址。在`trap.c`中我们已经提供了一个特殊的函数的开始`page_fault_handler`，来处理缺页异常。  
练习5：修改`trap_dispatch`来解包缺页异常到`page_fault_handler`。  
`trap_dispatch`:很简单的一个根据trapframe中的`trapno`进行跳转即可。  
`page_fault_handler`:这是一个神奇的东西，我本来想根据tf_cs的低两位的值判断是否是内核出错，但是却发现要和GD_KT作比较，虽然也可以理解，但是低两位应该也可以，暂时不知道为啥，另外内核发生缺页错误直接崩溃就行，照我的想法用户是要作映射的，但是这里貌似当用户发生缺页的时候也销毁该进程。  
### 断电异常  
断电异常，向量3,通常用来调试。它是通过暂时的用一个特殊的1字节`int3`软件中断指令代替相关的程序指令中来在一个程序的代码中添加断点。在JOS中我们将稍微模仿这个行为，通过将它转到一个原始的伪系统调用，该系统调用任何用户进程都能使用。这一使用方法事实上是合适的如果我们认为JOS内核观测器是一个原始的调试器。用户模式`panic`的完成就是在显示panic信息之后执行了`int 3`指令。  
练习6：修改`trap_dispatch`来使得断点异常接触内核观测器。  
`trap_distpatch`:英语菜。。没看懂。。。其实就是要调用monitor  
然而后面还有下文，害得我又捣鼓了半天。。  
问题：  
3. 断电测试有可能产生断点异常，也有可能产生保护错误（就是我），这是因为初始化IDT的方式不同。为什么？怎样设置才能使得断点异常像上面的那样工作？什么不正确的步骤会使得它生成一个保护异常？  
答：这个和之前回答过的产生保护异常的很像，害得我弄了半天才发现。因为从用户空间过来时中断向量的DPL设置成了0,这样从低特权级到高特权级就会产生保护异常，修改它和系统调用一样就行。
4. 你认为这些机制的点是什么？尤其是`user/softint`测试程序作了什么？  
答：看不太懂。。英文差。。。只是觉得它使用了一个`int`指令产生系统调用而已。。  
### 系统调用
用户进程通过系统调用让内核为它们做事情。当用户进程产生一个系统调用，处理器进入内核模式，处理器和内核联合保存用户进程的状态，内核执行适当的代码来完成系统调用，然后继续用户进程。具体的用户进程怎样引起内核的注意的细节以及它怎样确保是谁调用它在系统之间是不一样的。  
在JOS内核中，我们将使用`int`指令，引起处理器中断。特别的，我们使用`int  $0x30`作为系统调用中断。我们已经定义了常量`T_SYSCALL`为48.注意中断0x30可以被硬件产生，所以没有必要让用户代码来生成它？？  
应用将会在寄存器中传递系统调用号和系统调用参数。用这种方法，内核不会需要接触用户进程或是指令流。系统调用号在`eax`中，而参数将在`edx`，`ecx`，`ebx`，`edi`和`esi`中。内核通过`eax`把返回值传回。接触系统调用的汇编代码已经写了，在`syscall`中。  
练习7：其实就是补全系统调用，题目比较长就不说了，基本上就是使得程序能正常处理系统调用。比较关键的文件是`kern/syscall.c`。  
`syscall.c`:其实就是补全`syscall`函数，这个在xv6里面也有很相似的部分，只是那里更加精巧。这里就是根据头文件找到不同的系统调用号，然后调用不同的函数即可。`trapdispatch.c`:添加一个系统调用的判断，根据`syscall`的参数从`tf`中获取足够的信息并返回给`eax`寄存器即可。  
### 用户模式启动  
一个用户模式开始运行在`lib/entry.S`处。在一些设置之后，这个代码调用`libmain`，在`lib/libmain.c`中。你应该修改`libmain`来初始化全局指针`thisenv`指向这个进程的`struc Env`在`envs[]`数组中(注意`lib/entry.S`已经定义了`envs`来指向你设置的`UENVS`映射)。提示：看`inc/env.h`和使用`sys_getenvid`.  
`libmain`然后调用`umain`，在这个hello程序的情况下，是在`user/hello.c`中。注意在打印`hello, world`之后，它尝试接触`thisenv->env_id`。这是为什么它之前发生错误的原因。  
练习8：在用户的库中添加需要的代码，然后启动内核。接下去是应该看到的情况的说明，这里就不翻译了。  

