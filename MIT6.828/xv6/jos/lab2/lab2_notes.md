# lab2:内存管理  
## 一、介绍  
&emsp;&emsp;在这个实验中，你将为你的操作系统写内存管理的代码，内存管理有两个部分。  
&emsp;&emsp;第一个组成部分是内核的物理内存分配器，这样内核能分配和释放内存。你的分配器需要以4096字节为单元。你的任务是维持了个记录哪些物理页是自由的和哪些是已经被分配的，以及有多少进程在共享该页的数据结构。  
&emsp;&emsp;第二个部分是虚拟内存，映射被内核和用户软件使用的虚拟地址到物理内存地址。  

## 二、物理页面管理  
&emsp;&emsp;操作系统必须维持RAM的哪一部分是自由的，哪一部分在被使用。JOS使用页的粒度管理内存这样它能使用MMU来映射和保护每一部分被分配的内存。  
&emsp;&emsp;你将写物理内存分配器。它保持跟踪一个`struct PageInfo`的链表，每一个对应一个物理页。在你写其他的虚拟内存的完成之前，你需要写物理内存分配，因为你的页表管理代码需要分配物理内存来保存页表。  
&emsp;&emsp;练习1:在文件`kern/pmap.c`中，完成以下函数。  
`boot_alloc()`:这一简单的物理内存分配器只在JOS设置虚拟内存系统的时候才使用。`page_alloc()`才是真正的分配器。如果传入的参数是0,则返回下一页自由页的地址，如果传入的参数大于0,则分配足够的物理内存。这一函数的填写还是比较简单的，其中有个`nextfree`，指示下一页的空闲页所在处，当n等于0时返回它就行，当n大于0时则将它加上n并作地址对齐，然后把原始的旧地址返回给它即可。  
`mem_init`:这里只要先完成一点点就行，根据注释，是想分配一个`struct PageInfo`的数组来保持跟踪物理页，在每一个物理页，都有一个对应的`PageInfo`结构体在数组中与其对应。因此，只要简单的调用刚刚完成的`boot_alloc`分配足够的空间就行了。  
`page_init()`:这个嘛，其实就是根据物理内存，生成对应的空闲链表，但是对于内存空间现在还不太熟，尤其是最后一个选项，其他的都可以理解的，这里链表的生成方式比较6,可以看看。  
`page_alloc`:这个函数的作用就是分配一个物理页，这个挺简单的，我们知道`page_free_list`一直指向空闲链表的最前端，所以只要把第一页拿出来，再将`page_free_list`指向下一个空闲页，然后返回就行了。  
`page_free`:这就更简单了，直接把传入的参数页面，加入空闲链表顶端即可。  
## 三、虚拟内存  
&emsp;&emsp;在x86中，虚拟地址由段选择子和段内偏移组成，线性地址是你在段转换后在页转换之前得到的地址，物理地址是你最后在段和页转换之后以及最终通过硬件总线到RAM上的地址。  
&emsp;&emsp;C指针是虚拟地址中的`offset`成分，在`boot/boot.S`中，我们安装了一个全局描述符表`GDT`，在其中通过把所有的段基址为0以及限制为`0xffffffff`从而有效的抑制段机制。因此选择子没有影响而线性地址永远等于虚拟地址。在lab3中，我们将不得不接触更多的段来设置优先级，但是对于内存转换，我们可以忽视段而集中于页转换。  
&emsp;&emsp;回忆lab1的part3,我们安装了一个简单的页表这样内核可以在它的链接地址`0xf0100000`上运行，虽然它实际上被加载在就在0x00100000处，就在ROM BIOS之上。这一页表只映射了4M内存。在虚拟内存布局中你将在这一lab中为jos设置，我们将扩展这个来映射虚拟地址在0xf0000000处的开始的256M物理内存一体机映射一系列其他区域的虚拟内存。  
&emsp;&emsp;练习3：GDB只能通过虚拟地址接触QEMU的内存，而当设置虚拟内存的时候，能够观测物理内存的常常是有用的。使用`xp`命令，可以允许观测物理内存。  
在QEMU观测器中使用`xp`命令和在GDB中使用`x`指令来观测内存，确保对应地址看到的是相同的。  
&emsp;&emsp;从在CPU执行的代码上来，一旦我们在保护模式中，就没有办法直接使用线性地址或是物理地址，所有的内存引用都被当作虚拟地址，以及被MMU翻译，也就是所有的C指针都是虚拟地址。  
&emsp;&emsp;JOS内核经常需要操作地址作为操作数或是整数，并且不解引用它们，例如在物理内存分配器中。有时这些是虚拟地址，有时它们是物理地址，为了帮助记录代码，JOS在两种情况之下区分：类型`uintptr_t`表示操作数虚拟地址，而`physaddr_t`表示物理地址。这些类型都只是32位整数`uint32_t`,所以编译器不会阻止你从一种类型赋值给另一种类型。  
&emsp;&emsp;JOS内核可以解引用指针`uintptr_t`,但是需要首先转换它为指针类型。相反的，内核不能解引用物理地址，因为MMU会翻译所有的内存引用。如果你转换一个`physaddr_t`为一个指针并且解引用它，你可以加载和存储到对应的地址，但可能不是你原来打算的。  
&emsp;&emsp;问题：假设下列JOS内核代码是正确的，变量`x`是什么类型的，`uintptr_t`还是`physaddr_t`?  
```
	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;
```
答：应该是`uintptr_t`把，毕竟是指针。  
&emsp;&emsp;JOS内核有时需要读或者修改内存，对于该内存它只知道物理地址。例如，增加一个到页表的映射可能需要分配物理内存来保存页表目录以及初始化该内存。然而，内核和其他软件一样，不能越过虚拟内存转换因此不能直接加载和存储到物理地址中。一个JOS重新映射所有的从物理地址0,虚拟地址0xf0000000开始的物理内存的一个原因是帮助内核读和写它只知道的物理内存地址。为了翻译一个物理地址到虚拟地址，内核必须给物理地址增加0xf0000000来帮助物理地址在重新映射的区域找到对应的虚拟地址。你应该使用`KADDR(pa)`。  
&emsp;&emsp;JOS内核有时也需要在给出一个内核数据结构被存储的虚拟地址时找到对应的物理地址。内核的全局变量和被`boot_alloc`分配的内存在内核被加载的区域，从0xf0000000开始，我们映射所有的物理内存的`very region`。因此，为了转换虚拟地址到物理地址，内核可以只是减去0xf0000000.应该使用`PADDR(va)`.  
&emsp;&emsp;在将来的实验中你会经常有相同的物理页同时映射到多个虚拟地址。你将保持一个引用计数给每个物理页。当这一计数减为0,该页可以被释放因为它不再被使用。通常，这一计数应当和在所有页表中，在`UTOP`之下的物理页出现的次数相当。(在`UTOP`之上的映射大多在引导时被内核设置，从不应该被释放，所以没有必要对它们进行引用计数)。我们也将使用它保来持我们到页表目录页的指针的计数。  
&emsp;&emsp;使用`page_alloc`的时候要小心，它返回的页总是计数为0,所以`pp_ref`应当在你对返回的页做了什么时马上被增加。有时这是被其他函数处理的，(例如`page_insert`),有时调用`page_alloc`的函数必须直接完成它。
