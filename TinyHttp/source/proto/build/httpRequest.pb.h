// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: httpRequest.proto

#ifndef PROTOBUF_httpRequest_2eproto__INCLUDED
#define PROTOBUF_httpRequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_httpRequest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsrequestLineImpl();
void InitDefaultsrequestLine();
void InitDefaultsrequestHeadImpl();
void InitDefaultsrequestHead();
void InitDefaultsmainContentImpl();
void InitDefaultsmainContent();
void InitDefaultshttpRequestImpl();
void InitDefaultshttpRequest();
inline void InitDefaults() {
  InitDefaultsrequestLine();
  InitDefaultsrequestHead();
  InitDefaultsmainContent();
  InitDefaultshttpRequest();
}
}  // namespace protobuf_httpRequest_2eproto
namespace networkLearn {
class httpRequest;
class httpRequestDefaultTypeInternal;
extern httpRequestDefaultTypeInternal _httpRequest_default_instance_;
class mainContent;
class mainContentDefaultTypeInternal;
extern mainContentDefaultTypeInternal _mainContent_default_instance_;
class requestHead;
class requestHeadDefaultTypeInternal;
extern requestHeadDefaultTypeInternal _requestHead_default_instance_;
class requestLine;
class requestLineDefaultTypeInternal;
extern requestLineDefaultTypeInternal _requestLine_default_instance_;
}  // namespace networkLearn
namespace networkLearn {

// ===================================================================

class requestLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:networkLearn.requestLine) */ {
 public:
  requestLine();
  virtual ~requestLine();

  requestLine(const requestLine& from);

  inline requestLine& operator=(const requestLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  requestLine(requestLine&& from) noexcept
    : requestLine() {
    *this = ::std::move(from);
  }

  inline requestLine& operator=(requestLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const requestLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const requestLine* internal_default_instance() {
    return reinterpret_cast<const requestLine*>(
               &_requestLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(requestLine* other);
  friend void swap(requestLine& a, requestLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline requestLine* New() const PROTOBUF_FINAL { return New(NULL); }

  requestLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const requestLine& from);
  void MergeFrom(const requestLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(requestLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // string pathToResource = 2;
  void clear_pathtoresource();
  static const int kPathToResourceFieldNumber = 2;
  const ::std::string& pathtoresource() const;
  void set_pathtoresource(const ::std::string& value);
  #if LANG_CXX11
  void set_pathtoresource(::std::string&& value);
  #endif
  void set_pathtoresource(const char* value);
  void set_pathtoresource(const char* value, size_t size);
  ::std::string* mutable_pathtoresource();
  ::std::string* release_pathtoresource();
  void set_allocated_pathtoresource(::std::string* pathtoresource);

  // string httpVersion = 3;
  void clear_httpversion();
  static const int kHttpVersionFieldNumber = 3;
  const ::std::string& httpversion() const;
  void set_httpversion(const ::std::string& value);
  #if LANG_CXX11
  void set_httpversion(::std::string&& value);
  #endif
  void set_httpversion(const char* value);
  void set_httpversion(const char* value, size_t size);
  ::std::string* mutable_httpversion();
  ::std::string* release_httpversion();
  void set_allocated_httpversion(::std::string* httpversion);

  // @@protoc_insertion_point(class_scope:networkLearn.requestLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::google::protobuf::internal::ArenaStringPtr pathtoresource_;
  ::google::protobuf::internal::ArenaStringPtr httpversion_;
  mutable int _cached_size_;
  friend struct ::protobuf_httpRequest_2eproto::TableStruct;
  friend void ::protobuf_httpRequest_2eproto::InitDefaultsrequestLineImpl();
};
// -------------------------------------------------------------------

class requestHead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:networkLearn.requestHead) */ {
 public:
  requestHead();
  virtual ~requestHead();

  requestHead(const requestHead& from);

  inline requestHead& operator=(const requestHead& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  requestHead(requestHead&& from) noexcept
    : requestHead() {
    *this = ::std::move(from);
  }

  inline requestHead& operator=(requestHead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const requestHead& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const requestHead* internal_default_instance() {
    return reinterpret_cast<const requestHead*>(
               &_requestHead_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(requestHead* other);
  friend void swap(requestHead& a, requestHead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline requestHead* New() const PROTOBUF_FINAL { return New(NULL); }

  requestHead* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const requestHead& from);
  void MergeFrom(const requestHead& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(requestHead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string headTemp = 1;
  void clear_headtemp();
  static const int kHeadTempFieldNumber = 1;
  const ::std::string& headtemp() const;
  void set_headtemp(const ::std::string& value);
  #if LANG_CXX11
  void set_headtemp(::std::string&& value);
  #endif
  void set_headtemp(const char* value);
  void set_headtemp(const char* value, size_t size);
  ::std::string* mutable_headtemp();
  ::std::string* release_headtemp();
  void set_allocated_headtemp(::std::string* headtemp);

  // @@protoc_insertion_point(class_scope:networkLearn.requestHead)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr headtemp_;
  mutable int _cached_size_;
  friend struct ::protobuf_httpRequest_2eproto::TableStruct;
  friend void ::protobuf_httpRequest_2eproto::InitDefaultsrequestHeadImpl();
};
// -------------------------------------------------------------------

class mainContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:networkLearn.mainContent) */ {
 public:
  mainContent();
  virtual ~mainContent();

  mainContent(const mainContent& from);

  inline mainContent& operator=(const mainContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  mainContent(mainContent&& from) noexcept
    : mainContent() {
    *this = ::std::move(from);
  }

  inline mainContent& operator=(mainContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const mainContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mainContent* internal_default_instance() {
    return reinterpret_cast<const mainContent*>(
               &_mainContent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(mainContent* other);
  friend void swap(mainContent& a, mainContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline mainContent* New() const PROTOBUF_FINAL { return New(NULL); }

  mainContent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const mainContent& from);
  void MergeFrom(const mainContent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(mainContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bodyTemp = 1;
  void clear_bodytemp();
  static const int kBodyTempFieldNumber = 1;
  const ::std::string& bodytemp() const;
  void set_bodytemp(const ::std::string& value);
  #if LANG_CXX11
  void set_bodytemp(::std::string&& value);
  #endif
  void set_bodytemp(const char* value);
  void set_bodytemp(const char* value, size_t size);
  ::std::string* mutable_bodytemp();
  ::std::string* release_bodytemp();
  void set_allocated_bodytemp(::std::string* bodytemp);

  // @@protoc_insertion_point(class_scope:networkLearn.mainContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bodytemp_;
  mutable int _cached_size_;
  friend struct ::protobuf_httpRequest_2eproto::TableStruct;
  friend void ::protobuf_httpRequest_2eproto::InitDefaultsmainContentImpl();
};
// -------------------------------------------------------------------

class httpRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:networkLearn.httpRequest) */ {
 public:
  httpRequest();
  virtual ~httpRequest();

  httpRequest(const httpRequest& from);

  inline httpRequest& operator=(const httpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  httpRequest(httpRequest&& from) noexcept
    : httpRequest() {
    *this = ::std::move(from);
  }

  inline httpRequest& operator=(httpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const httpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const httpRequest* internal_default_instance() {
    return reinterpret_cast<const httpRequest*>(
               &_httpRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(httpRequest* other);
  friend void swap(httpRequest& a, httpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline httpRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  httpRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const httpRequest& from);
  void MergeFrom(const httpRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(httpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string CRLF = 3;
  void clear_crlf();
  static const int kCRLFFieldNumber = 3;
  const ::std::string& crlf() const;
  void set_crlf(const ::std::string& value);
  #if LANG_CXX11
  void set_crlf(::std::string&& value);
  #endif
  void set_crlf(const char* value);
  void set_crlf(const char* value, size_t size);
  ::std::string* mutable_crlf();
  ::std::string* release_crlf();
  void set_allocated_crlf(::std::string* crlf);

  // .networkLearn.requestLine resLine = 1;
  bool has_resline() const;
  void clear_resline();
  static const int kResLineFieldNumber = 1;
  const ::networkLearn::requestLine& resline() const;
  ::networkLearn::requestLine* release_resline();
  ::networkLearn::requestLine* mutable_resline();
  void set_allocated_resline(::networkLearn::requestLine* resline);

  // .networkLearn.requestHead resHead = 2;
  bool has_reshead() const;
  void clear_reshead();
  static const int kResHeadFieldNumber = 2;
  const ::networkLearn::requestHead& reshead() const;
  ::networkLearn::requestHead* release_reshead();
  ::networkLearn::requestHead* mutable_reshead();
  void set_allocated_reshead(::networkLearn::requestHead* reshead);

  // .networkLearn.mainContent body = 4;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 4;
  const ::networkLearn::mainContent& body() const;
  ::networkLearn::mainContent* release_body();
  ::networkLearn::mainContent* mutable_body();
  void set_allocated_body(::networkLearn::mainContent* body);

  // @@protoc_insertion_point(class_scope:networkLearn.httpRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr crlf_;
  ::networkLearn::requestLine* resline_;
  ::networkLearn::requestHead* reshead_;
  ::networkLearn::mainContent* body_;
  mutable int _cached_size_;
  friend struct ::protobuf_httpRequest_2eproto::TableStruct;
  friend void ::protobuf_httpRequest_2eproto::InitDefaultshttpRequestImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// requestLine

// string method = 1;
inline void requestLine::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& requestLine::method() const {
  // @@protoc_insertion_point(field_get:networkLearn.requestLine.method)
  return method_.GetNoArena();
}
inline void requestLine::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkLearn.requestLine.method)
}
#if LANG_CXX11
inline void requestLine::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkLearn.requestLine.method)
}
#endif
inline void requestLine::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkLearn.requestLine.method)
}
inline void requestLine::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkLearn.requestLine.method)
}
inline ::std::string* requestLine::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:networkLearn.requestLine.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* requestLine::release_method() {
  // @@protoc_insertion_point(field_release:networkLearn.requestLine.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void requestLine::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:networkLearn.requestLine.method)
}

// string pathToResource = 2;
inline void requestLine::clear_pathtoresource() {
  pathtoresource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& requestLine::pathtoresource() const {
  // @@protoc_insertion_point(field_get:networkLearn.requestLine.pathToResource)
  return pathtoresource_.GetNoArena();
}
inline void requestLine::set_pathtoresource(const ::std::string& value) {
  
  pathtoresource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkLearn.requestLine.pathToResource)
}
#if LANG_CXX11
inline void requestLine::set_pathtoresource(::std::string&& value) {
  
  pathtoresource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkLearn.requestLine.pathToResource)
}
#endif
inline void requestLine::set_pathtoresource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pathtoresource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkLearn.requestLine.pathToResource)
}
inline void requestLine::set_pathtoresource(const char* value, size_t size) {
  
  pathtoresource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkLearn.requestLine.pathToResource)
}
inline ::std::string* requestLine::mutable_pathtoresource() {
  
  // @@protoc_insertion_point(field_mutable:networkLearn.requestLine.pathToResource)
  return pathtoresource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* requestLine::release_pathtoresource() {
  // @@protoc_insertion_point(field_release:networkLearn.requestLine.pathToResource)
  
  return pathtoresource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void requestLine::set_allocated_pathtoresource(::std::string* pathtoresource) {
  if (pathtoresource != NULL) {
    
  } else {
    
  }
  pathtoresource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pathtoresource);
  // @@protoc_insertion_point(field_set_allocated:networkLearn.requestLine.pathToResource)
}

// string httpVersion = 3;
inline void requestLine::clear_httpversion() {
  httpversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& requestLine::httpversion() const {
  // @@protoc_insertion_point(field_get:networkLearn.requestLine.httpVersion)
  return httpversion_.GetNoArena();
}
inline void requestLine::set_httpversion(const ::std::string& value) {
  
  httpversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkLearn.requestLine.httpVersion)
}
#if LANG_CXX11
inline void requestLine::set_httpversion(::std::string&& value) {
  
  httpversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkLearn.requestLine.httpVersion)
}
#endif
inline void requestLine::set_httpversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  httpversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkLearn.requestLine.httpVersion)
}
inline void requestLine::set_httpversion(const char* value, size_t size) {
  
  httpversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkLearn.requestLine.httpVersion)
}
inline ::std::string* requestLine::mutable_httpversion() {
  
  // @@protoc_insertion_point(field_mutable:networkLearn.requestLine.httpVersion)
  return httpversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* requestLine::release_httpversion() {
  // @@protoc_insertion_point(field_release:networkLearn.requestLine.httpVersion)
  
  return httpversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void requestLine::set_allocated_httpversion(::std::string* httpversion) {
  if (httpversion != NULL) {
    
  } else {
    
  }
  httpversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), httpversion);
  // @@protoc_insertion_point(field_set_allocated:networkLearn.requestLine.httpVersion)
}

// -------------------------------------------------------------------

// requestHead

// string headTemp = 1;
inline void requestHead::clear_headtemp() {
  headtemp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& requestHead::headtemp() const {
  // @@protoc_insertion_point(field_get:networkLearn.requestHead.headTemp)
  return headtemp_.GetNoArena();
}
inline void requestHead::set_headtemp(const ::std::string& value) {
  
  headtemp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkLearn.requestHead.headTemp)
}
#if LANG_CXX11
inline void requestHead::set_headtemp(::std::string&& value) {
  
  headtemp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkLearn.requestHead.headTemp)
}
#endif
inline void requestHead::set_headtemp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  headtemp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkLearn.requestHead.headTemp)
}
inline void requestHead::set_headtemp(const char* value, size_t size) {
  
  headtemp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkLearn.requestHead.headTemp)
}
inline ::std::string* requestHead::mutable_headtemp() {
  
  // @@protoc_insertion_point(field_mutable:networkLearn.requestHead.headTemp)
  return headtemp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* requestHead::release_headtemp() {
  // @@protoc_insertion_point(field_release:networkLearn.requestHead.headTemp)
  
  return headtemp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void requestHead::set_allocated_headtemp(::std::string* headtemp) {
  if (headtemp != NULL) {
    
  } else {
    
  }
  headtemp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headtemp);
  // @@protoc_insertion_point(field_set_allocated:networkLearn.requestHead.headTemp)
}

// -------------------------------------------------------------------

// mainContent

// string bodyTemp = 1;
inline void mainContent::clear_bodytemp() {
  bodytemp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& mainContent::bodytemp() const {
  // @@protoc_insertion_point(field_get:networkLearn.mainContent.bodyTemp)
  return bodytemp_.GetNoArena();
}
inline void mainContent::set_bodytemp(const ::std::string& value) {
  
  bodytemp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkLearn.mainContent.bodyTemp)
}
#if LANG_CXX11
inline void mainContent::set_bodytemp(::std::string&& value) {
  
  bodytemp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkLearn.mainContent.bodyTemp)
}
#endif
inline void mainContent::set_bodytemp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bodytemp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkLearn.mainContent.bodyTemp)
}
inline void mainContent::set_bodytemp(const char* value, size_t size) {
  
  bodytemp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkLearn.mainContent.bodyTemp)
}
inline ::std::string* mainContent::mutable_bodytemp() {
  
  // @@protoc_insertion_point(field_mutable:networkLearn.mainContent.bodyTemp)
  return bodytemp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mainContent::release_bodytemp() {
  // @@protoc_insertion_point(field_release:networkLearn.mainContent.bodyTemp)
  
  return bodytemp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mainContent::set_allocated_bodytemp(::std::string* bodytemp) {
  if (bodytemp != NULL) {
    
  } else {
    
  }
  bodytemp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bodytemp);
  // @@protoc_insertion_point(field_set_allocated:networkLearn.mainContent.bodyTemp)
}

// -------------------------------------------------------------------

// httpRequest

// .networkLearn.requestLine resLine = 1;
inline bool httpRequest::has_resline() const {
  return this != internal_default_instance() && resline_ != NULL;
}
inline void httpRequest::clear_resline() {
  if (GetArenaNoVirtual() == NULL && resline_ != NULL) {
    delete resline_;
  }
  resline_ = NULL;
}
inline const ::networkLearn::requestLine& httpRequest::resline() const {
  const ::networkLearn::requestLine* p = resline_;
  // @@protoc_insertion_point(field_get:networkLearn.httpRequest.resLine)
  return p != NULL ? *p : *reinterpret_cast<const ::networkLearn::requestLine*>(
      &::networkLearn::_requestLine_default_instance_);
}
inline ::networkLearn::requestLine* httpRequest::release_resline() {
  // @@protoc_insertion_point(field_release:networkLearn.httpRequest.resLine)
  
  ::networkLearn::requestLine* temp = resline_;
  resline_ = NULL;
  return temp;
}
inline ::networkLearn::requestLine* httpRequest::mutable_resline() {
  
  if (resline_ == NULL) {
    resline_ = new ::networkLearn::requestLine;
  }
  // @@protoc_insertion_point(field_mutable:networkLearn.httpRequest.resLine)
  return resline_;
}
inline void httpRequest::set_allocated_resline(::networkLearn::requestLine* resline) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resline_;
  }
  if (resline) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resline = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resline, submessage_arena);
    }
    
  } else {
    
  }
  resline_ = resline;
  // @@protoc_insertion_point(field_set_allocated:networkLearn.httpRequest.resLine)
}

// .networkLearn.requestHead resHead = 2;
inline bool httpRequest::has_reshead() const {
  return this != internal_default_instance() && reshead_ != NULL;
}
inline void httpRequest::clear_reshead() {
  if (GetArenaNoVirtual() == NULL && reshead_ != NULL) {
    delete reshead_;
  }
  reshead_ = NULL;
}
inline const ::networkLearn::requestHead& httpRequest::reshead() const {
  const ::networkLearn::requestHead* p = reshead_;
  // @@protoc_insertion_point(field_get:networkLearn.httpRequest.resHead)
  return p != NULL ? *p : *reinterpret_cast<const ::networkLearn::requestHead*>(
      &::networkLearn::_requestHead_default_instance_);
}
inline ::networkLearn::requestHead* httpRequest::release_reshead() {
  // @@protoc_insertion_point(field_release:networkLearn.httpRequest.resHead)
  
  ::networkLearn::requestHead* temp = reshead_;
  reshead_ = NULL;
  return temp;
}
inline ::networkLearn::requestHead* httpRequest::mutable_reshead() {
  
  if (reshead_ == NULL) {
    reshead_ = new ::networkLearn::requestHead;
  }
  // @@protoc_insertion_point(field_mutable:networkLearn.httpRequest.resHead)
  return reshead_;
}
inline void httpRequest::set_allocated_reshead(::networkLearn::requestHead* reshead) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reshead_;
  }
  if (reshead) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reshead = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reshead, submessage_arena);
    }
    
  } else {
    
  }
  reshead_ = reshead;
  // @@protoc_insertion_point(field_set_allocated:networkLearn.httpRequest.resHead)
}

// string CRLF = 3;
inline void httpRequest::clear_crlf() {
  crlf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& httpRequest::crlf() const {
  // @@protoc_insertion_point(field_get:networkLearn.httpRequest.CRLF)
  return crlf_.GetNoArena();
}
inline void httpRequest::set_crlf(const ::std::string& value) {
  
  crlf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkLearn.httpRequest.CRLF)
}
#if LANG_CXX11
inline void httpRequest::set_crlf(::std::string&& value) {
  
  crlf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkLearn.httpRequest.CRLF)
}
#endif
inline void httpRequest::set_crlf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  crlf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkLearn.httpRequest.CRLF)
}
inline void httpRequest::set_crlf(const char* value, size_t size) {
  
  crlf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkLearn.httpRequest.CRLF)
}
inline ::std::string* httpRequest::mutable_crlf() {
  
  // @@protoc_insertion_point(field_mutable:networkLearn.httpRequest.CRLF)
  return crlf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* httpRequest::release_crlf() {
  // @@protoc_insertion_point(field_release:networkLearn.httpRequest.CRLF)
  
  return crlf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void httpRequest::set_allocated_crlf(::std::string* crlf) {
  if (crlf != NULL) {
    
  } else {
    
  }
  crlf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crlf);
  // @@protoc_insertion_point(field_set_allocated:networkLearn.httpRequest.CRLF)
}

// .networkLearn.mainContent body = 4;
inline bool httpRequest::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void httpRequest::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::networkLearn::mainContent& httpRequest::body() const {
  const ::networkLearn::mainContent* p = body_;
  // @@protoc_insertion_point(field_get:networkLearn.httpRequest.body)
  return p != NULL ? *p : *reinterpret_cast<const ::networkLearn::mainContent*>(
      &::networkLearn::_mainContent_default_instance_);
}
inline ::networkLearn::mainContent* httpRequest::release_body() {
  // @@protoc_insertion_point(field_release:networkLearn.httpRequest.body)
  
  ::networkLearn::mainContent* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::networkLearn::mainContent* httpRequest::mutable_body() {
  
  if (body_ == NULL) {
    body_ = new ::networkLearn::mainContent;
  }
  // @@protoc_insertion_point(field_mutable:networkLearn.httpRequest.body)
  return body_;
}
inline void httpRequest::set_allocated_body(::networkLearn::mainContent* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:networkLearn.httpRequest.body)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace networkLearn

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_httpRequest_2eproto__INCLUDED
